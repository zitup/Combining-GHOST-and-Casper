## 主要协议：Gasper

现在我们定义我们的主要协议 Gasper，它是 GHOST 和 Casper FFG 思想的结合。主要概念包括：

- 链的 _（时期边界）对（(Epoch boundary) pairs）_ ：给定⼀条链，会挑选出某些区块（理想情况下每个时期⼀个）来充当 Casper 的检查点 _（checkpoints）_。但是，⼀个区块可能会在同⼀条链上多次作为检查点出现（这是 Casper 中没有的细微差别；我们将在第 4.1 节中对此进⾏阐述），因此我们使⽤有序的 pairs (B, j)，来消除歧义，其中 B 是区块，j 是时期。这些将被称为时期边界对，或简称为对。
- _委员会（Committees）_ ：验证者在每个时期中被划分为委员会，每个插槽⼀个委员会。在每个插槽中，来⾃指定委员会的⼀名验证者会提出⼀个区块。然后，该委员会的所有成员将使⽤分叉选择规则 HLMD GHOST（LMD GHOST 的轻微变体）来证明他们所看到的链头（希望是刚刚提出的区块）。
- _证明和最终确定（Justification and Finalization）_ ：这些概念实际上与 Casper FFG 的概念相同，只是我们证明和最终确定对，⽽不是证明和最终确定检查点块，即，给定视图 G，J(G) 和 F(G) 是成对的集合。

### 4.1 时期边界块和对

回想⼀下，任何特定的区块 B 都唯⼀地确定了⼀条链，即 chain(B)。对于区块 B 和时期 j，定义 EBB(B, j) —— 区块 B 的第 j 个时期边界区块，为 chain(B) 中最⾼插槽⼩于或等于 jC 的区块。让最新的此类区块为 LEBB(B)，或最后⼀个时期边界区块（B 的）。我们做了⼀些观察：

- 对于每个区块 B，EBB(B, 0) = B<sub>genesis</sub>。
- 更⼀般地，如果对于某个时期 j，slot(B) = jC，则 B 将成为包含它的每个链中的时期边界区块。
- 但是，如果没有这样的假设，⼀个区块可能在某些链中是时期边界区块，但在其他链中则不是。

为了消除此类情况的歧义，我们通过引⼊时期边界对（简称对）(B, j) 来提⾼精度，其中 B 是区块，j 是时期。我们的主要证明和最终化概念将基于这些对来完成。给定⼀个对 P = (B, j)，我们说 P 具有*证明时期 j（ attestation epoch j）*，使⽤符号 aep(P) = j，这不⼀定与 ep(B) 相同。

![](/images/figure-4.png)  
图 4：时期边界区块和对的⽰例。区块标有其插槽号。“63”不是实际的区块，但说明了 66 需要插槽 64 上的时期边界区块但未能找到的视⻆。

**⽰例 4.1。** 假设区块（以 slot 为标签）形成链 63 ← 64 ← 65，并且存在分叉 63 ← 66。那么 EBB(65, 1) = 64，因为 64 在 chain(65) 中。当我们尝试查找 EBB(66, 1) 时，我们会查找区块 64，因为我们处于时期 1，并且意识到它不在链(66)中，因此我们必须向后查找并从上⼀个时期中“拉出”区块 63，以作为这条链的时期边界区块。这在图 4 中⽤虚线部分表⽰。观察即使 aep(63, 1) 和 ep(63) = 0，ep() 也是⼀个仅依赖于块槽的局部属性，⽽像 aep() 这样的时期边界概念则依赖于链的上下文。  
**备注。** 我们进⼀步解释了为什么我们使⽤成对的区块⽽不是检查点区块。Casper FFG 是⼀种“最终性⼩⼯具”，这意味着它旨在在具有概率活性的区块链之上放置⼀层最终性，区块链提供稳定的新检查点区块供应。概率活性假设良好的同步条件。对于设计的安全性部分，我们希望做出更少的假设，并考虑最坏的情况，即我们可能会处于⼀段时间内没有看到新区块的状态。

例如，区块 B 可能是来⾃ epoch 1 的链头，但⽬前处于 epoch 3，且没有在 B 之上构建新区块。在原始 Casper FFG 中，我们期望概率活性，因此我们在每个 epoch 都会有⼀个不同的检查点。但是，当我们没有同步假设时，在分析中我们需要区分“epoch 2 中的检查点”和“epoch 3 中的检查点”的概念，即使两者的最佳候选都是 B，⽽ B 本⾝仍然只处于 epoch 1！这⾃然会引出概念 (B, 2) 和 (B, 3)，如果“应该在那⾥”的检查点区块缺失，则它们表⽰对后续 epoch 中检查点的最佳近似。

此外，Casper FFG 不对底层区块链中的时间做出任何假设只有区块⾼度很重要，没有插槽或时期的概念。在工作量证明区块链中，使用区块高度是一个自然的选择，因为挖掘新区块的[泊松过程](https://zh.wikipedia.org/zh-cn/%E6%B3%8A%E6%9D%BE%E8%BF%87%E7%A8%8B)在某种程度上起到了系统时钟的作用，而区块的出现时间相当不规则。作为⼀种权益证明协议，Gasper 可以将区块以受控的定期间隔作为协议的⼀部分（⽽不是依赖于随机过程）⽣成，因此协议中明确需要时间概念。为了捕捉这个时间概念，我们区块链中的每个对象⾃然需要了解数据（在区块中捕获）和时间（在时期计数中捕获），这也⾃然⽽然地引出了配对的概念。

### 4.2 委员会

委员会的⽬的是在验证者之间分配职责。⾸先，假设验证者可以访问⼀系列随机⻓度为 N 的排列 $ρ0、ρ1、...$，作为函数 $\{1、2、...、N\} → \{1、2、...、N\}$。在本⽂的范围内，我们假设我们从随机预⾔机中获得这些随机排列。

召回时间被分为⼏个时期，每个时期有 $C$ 个插槽。每个排列 $ρj$ 将仅在时期 $j$ 期间使⽤。其作⽤是伪随机地将验证者选⼊ $C$ 个$委员会（committees）$，每个委员会负责⼀个时期的⼀个插槽。准确地说：

- 在时期 $j$ 期间，我们希望将验证者集合 $V$ 分成 $C$ 个⼤⼩相等的委员会 $S0, S1, . . . , SC−1$ （为了便于表⽰，我们假设 $C|N$；处理“大致相等”规模的委员会并不会改变我们方法的本质）。
- 因此，对于每个 $k ∈ \{0, 1, . . . , C −1\}$，我们将 $S$<sub>$k$</sub> 定义为 $V$<sub>$ρj(s)$</sub> 形式的 $N/C$ 验证者集合，其中 $s$ ≡ $k$ (mod $C$)。注意，对于时期 $j$，集合 $S0, S1, . . . , SC−1$ 根据需要将整个验证者集合 $\{V1, . . . , VN \}$ 划分到时期 $j$ 的所有插槽中。

总⽽⾔之，在每个时期 $j$ 中， $ρj$ 允许我们将验证者随机分配到 $C$ 个委员会中。我们的⼯作并没有假设超出这个直觉。

### 4.3 区块和证明

现在，在每个插槽中，协议规定了分配给各⾃插槽的委员会的两种“委员会⼯作”：委员会中的⼀个⼈需要$提议（propose）$⼀个新区块，委员会中的每个⼈都需要证明他们的链头。提议区块和证明都意味着⽴即将相应的消息（分别为区块和证明）添加到验证者⾃⼰的视图中，然后将消息⼴播到⽹络。回想⼀下，提议（⾮创世）区块和发布证明的消息都有数字签名。

提议和证明都要求委员会成员在验证者⾃⼰的视图上运⾏相同的分叉选择规则 HLMD()，这是 LMD GHOST 分叉选择规则的变体。HLMD() 的定义需要我们尚未介绍的概念，因此我们将其定义推迟到第 4.6 节。⽬前，我们唯⼀需要知道的是，与 LMD GHOST ⼀样，HLMD() 接受视图 $G$ 并返回叶块 B 作为链的头部，使 chain(B) 成为 $G$ 的规范链。

我们现在介绍在插槽 $i = jC+k$ 期间协议的职责，其中 $k ∈ \{0, 1, . . . , C−1\}$。所有时间提及都是从验证者本地时钟的⻆度计算的，我们假设该时钟在某个增量内同步。

**定义 4.2。** 在插槽 $i = jC + k$ 的开始，指定验证者 $V = V$<sub>$ρj(k)$</sub> ，即时期 $j$ 的委员会 $S$<sub>$k$</sub> 的第⼀位成员，为该插槽的提议者$（proposer）$。提议者计算他/她认为的链的规范头，即 HLMD(view($V, i$)) = $B'$，然后提议⼀个区块 $(proposes\ a\ block)$ B，该区块是⼀条包含以下内容的消息：

1. slot(B) = $i$, 插槽号。
2. P($B$) = $B'$，指向⽗块的指针；换句话说，我们总是在链头顶部构建⼀个块
3. newattests($B$)，⼀组指向所有证明$(attestations)$（将在下⽂定义）的指针，$V$ 已经接受这些证明，但还未将其包含在作为 $B$ 祖先的区块 $B'$ 的任何 newattests($B'$) 中。
4. ⼀些特定于实现的数据（例如，如果我们正在追踪硬币，“Yunice 向 Brad ⽀付了 4.2 ETH”），其语义与我们⽆关。

对于依赖关系，$B$ 依赖于 $P(B)$ 和 newattests($B$) 中的所有证明。（例如，如果我们在⽹络上看到⼀个块，但看不到它的⽗块，我们会忽略该块，直到我们看到它的⽗块）。

在典型的（诚实）⾏为中，我们可以假设每个与区块关联的插槽号在 view(NW) 中也最多有⼀个这样的区块。默认情况下，$B$<sub>genesis</sub> 是具有插槽 0 的唯⼀区块。理论上，不诚实的验证者可以创建⼀个与现有区块具有重复插槽号的区块，但我们可以假设，⽤于区块提议选择的数字签名和伪随机⽣成器已经设置好，因此这种⾏为可以被可验证地捕获。例如，每次数字签名的区块进⼊验证者的视野时，验证者都可以⽴即检查区块提议者是否是被允许为相应插槽提议区块的唯⼀⼈员。验证者还可以通过仅指向两个区块来证明同⼀个⼈在同⼀个插槽中提出了两个区块。

**定义 4.3。** 在时间 $(i + 1/2)$，即插槽 $i = jC + k$ 的中间，委员会 $S$<sub>$k$</sub> 中的每个验证者 $V$ 计算 $B'$ = HLMD (view($V,i + 1/2$))，并发布证明 $α$，该证明是⼀条包含以下内容的消息：

1. slot$(α) = jC + k$，验证者进⾏证明的插槽。我们还将使⽤ ep(α) 作为 ep(slot(α)) 的简写。
2. block$(α) = B'$ 。我们说 α 证明了 block(α)。我们将得到 slot(block(α)) ≤ slot(α)，并且“通常”通过快速证明刚刚在插槽中提议的块来获得相等。
3. 检查点边 LJ(α) → LE(α)。这⾥，LJ(α) 和 LE(α) 是 view($V,i + 1/2$) 中的时期边界对。我们将在第 4.4 节中正确定义它们。

对于依赖项，α 依赖于 block(α)。因此，我们会忽略证明，直到它所证明的区块被接受到我们的视图中（这是理论和实现之间的较⼤差异之⼀；我们将在第 8 节中对此进⾏更多讨论）。

直观地看，α 同时在做两件事：它既是其区块的“GHOST 投票”，也是两个时期边界对之间转换的“Casper FFG 投票”（类似于 Casper 的检查点区块）。
